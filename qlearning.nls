extensions [csv]

globals [
  episodes    ;; number of episodes for test
  steps       ;; number of steps per episode
  gamma       ;; discount factor
  lr          ;; learning rate
  er          ;; exploration rate
  min-er      ;; min exploration rate
  max-er      ;; max exploration rate
  decay-rate  ;; decay rate
  quality     ;; quality matrix
  curr-state  ;; current state
]

to reset-episode [from-file?]
  set gamma 0.7
  set lr 1
  set er 1.0
  set min-er 0.01
  set max-er 1.0
  set decay-rate 0.01
  set episodes 1000
  set steps 1000
  
  set curr-state (list 0 0 0 0)
  
  set quality table:make
  
  ;; initilize the quality matrix or load from file
  ifelse not from-file? [
    init-quality
  ][
    load-quality
  ]
end


to init-quality
  foreach (range min-pxcor (max-pxcor + 1)) [ ball-x ->
    foreach (range min-pycor (max-pycor + 1)) [ ball-y ->
      foreach (range 0 5) [ ball-angle ->
        foreach (range min-pxcor (max-pxcor + 1)) [ paddle-x ->
          let key (get-key-from-state (list ball-x ball-y ball-angle paddle-x))
          set key (word key)
          
          table:put quality key [0 0]
        ]
      ]
    ]
  ]
end


to run-episode [update-function stop-function]
  ;; show "test functions get-index-from-state and get-state-from-index" 
  ;; show get-key-from-state (list 16 16 4 16) 
  ;; show get-key-from-state (list -16 -16 0 -16) 
  ;; show get-state-from-key "32320532"
  ;; show get-state-from-key "0"
  ;; stop
  
  repeat steps [
    let action choose-action curr-state
    
    set curr-state (runresult update-function action)  ;; callback to update the graphics
    
    let new-state perform-step action
    
    let reward (get-reward new-state action)
    
    let curr-state-key (get-key-from-state new-state)
    let next-state-key (get-key-from-state new-state)

    let next-actions (table:get quality next-state-key)

    let next-quality (item action next-actions)  ;; Q(s', a')
    let curr-quality (item action (table:get quality curr-state-key))  ;; Q(s, a)

    ;; Q(s,a) := Q(s,a) + lr [R(s,a) + gamma * max Q(s',a') - Q(s,a)]    
    let new-quality curr-quality + lr * ((reward + gamma * max next-actions) - curr-quality)
    
    ;; set the new quality given the action
    let curr-actions (table:get quality curr-state-key)
    set curr-actions (replace-item action curr-actions new-quality)
    
    table:put quality curr-state-key curr-actions
    
    set curr-state new-state
  ]
  
  run stop-function
  save-quality
  
  
end


to run-episode-series [update-function stop-function]
  let n 0
  repeat episodes [
    show word "episode: " (n + 1)
   
    reset-episode false
    run-episode update-function stop-function
    
    ;; exploration/eploitation rate decay
    set er (min-er + (max-er - min-er) * exp(- decay-rate * n))
    
    set n n + 1 
  ]
end

to-report perform-step [action]
  let next-state curr-state         ;; copy current state
  let paddle-x (item 3 next-state)
  
  set paddle-x paddle-x + (ifelse-value action = 0 [-1] [1])
  
  if paddle-x > 16 [
    set paddle-x 16
  ]
  
  if paddle-x < -16 [
    set paddle-x -16
  ]
   
  report replace-item 3 next-state paddle-x  ;; replace with the new paddle position
end


to-report get-best-action [state]  
  ;; get quality values for each action given the current state
  let state-key (get-key-from-state state)
  let row table:get quality state-key
  
  ;; return the action with max quality
  report ifelse-value (item 0 row > item 1 row) [0] [1]
end


to-report choose-action [state]
  ifelse random-float 1 > er [
    report get-best-action state
  ][
    report int(random 2)
  ]
end



;; TODO: aggiustare ball-angle in base al range di valori
to-report get-key-from-state [state]
  let ball-x (item 0 state)
  let ball-y (item 1 state)
  let ball-angle (item 2 state)
  let paddle-x (item 3 state)
  
  let key ((ball-x + max-pxcor) * 1000000 + (ball-y + max-pycor) * 10000 + (ball-angle) * 100 + (paddle-x + max-pxcor))
  report (word key)
end


;; TODO: aggiustare ball-angle in base al range di valori
to-report get-state-from-key [string-key]
  let key (read-from-string string-key)
  
  let paddle-x (key mod 100)
  let ball-angle ((key mod 10000) - paddle-x) / 100
  let ball-y ((((key mod 1000000) - paddle-x) / 100) - ball-angle) / 100
  let ball-x (((((key mod 100000000) - paddle-x) / 100) - ball-angle) / 100 - ball-y) / 100
  
  show (list ball-x ball-y ball-angle paddle-x)
  
  set paddle-x paddle-x - (max-pxcor)
  set ball-angle ball-angle
  set ball-y ball-y - (max-pycor)
  set ball-x ball-x - (max-pxcor)
  
  report (list ball-x ball-y ball-angle paddle-x)
end


to-report get-reward [state action]
  let ball-x (item 0 state)
  let ball-y (item 1 state)
  let paddle-x (item 3 state)
  
  if ball-x != paddle-x [
    ;; player 1 loses
    if ball-y = min-pycor [
      report -1               
    ]
    
    ;; player 2 loses
    if ball-y = max-pycor [
      report 1               
    ]
  ]
  report 0  ;; nothing happens
end


to save-quality
  file-open "./quality.csv"
  file-print csv:to-string table:to-list quality
  file-close
end

to load-quality
  let quality-list (csv:from-file "./quality.csv")
  set quality (table:from-list quality-list)
  ;; TODO: sostituire le chiavi
end

