globals [
  episodes    ;; number of episodes for test
  steps       ;; number of steps per episode
  gamma       ;; discount factor
  lr          ;; learning rate
  er          ;; exploration rate
  quality     ;; quality matrix
  curr-state  ;; current state
]

to reset-episode
  set gamma 0.8
  set lr 1
  set episodes 1000
  set steps 1000
  
  set curr-state (list 0 0 0 0)
  
  set quality table:make
  init-quality
end


to init-quality
  foreach (range min-pxcor (max-pxcor + 1)) [ ball-x ->
    foreach (range min-pycor (max-pycor + 1)) [ ball-y ->
      foreach (range 0 5) [ ball-angle ->
        foreach (range min-pxcor (max-pxcor + 1)) [ paddle-x ->
          let key (get-key-from-state (list ball-x ball-y ball-angle paddle-x))
          set key (word key)
          
          table:put quality key [0 0]
        ]
      ]
    ]
  ]
  show table:length quality
end


to run-episode [update-function stop-function]
  ;; show "test functions get-index-from-state and get-state-from-index" 
  ;; show get-key-from-state (list 16 16 4 16) 
  ;; show get-key-from-state (list -16 -16 0 -16) 
  ;; show get-state-from-key "32320532"
  ;; show get-state-from-key "0"
  ;; stop
  
  repeat steps [
    let action choose-action curr-state
    
    (run update-function action)  ;; callback to update the graphics
    
    let new-state perform-step action
    
    let reward (get-reward new-state action)
    
    ;; Q(s,a) := Q(s,a) + lr [R(s,a) + gamma * max Q(s',a') - Q(s,a)]
    ;; Q(s,a) := R(s,a) + gamma * max Q(s',a') simple version for now
    let curr-state-key (get-key-from-state new-state)
    let next-state-key (get-key-from-state new-state)
    let new-quality (reward + gamma * max (table:get quality next-state-key))
    
    ;; set the new quality given the action
    let actions (table:get quality curr-state-key)
    set actions (replace-item action actions new-quality)
    table:put quality curr-state-key actions
    
    ;; show new-quality
    
    set curr-state new-state
  ]
  run stop-function
end


to-report perform-step [action]
  let next-state curr-state         ;; copy current state
  let paddle-x (item 3 next-state)
  
  set paddle-x paddle-x + (ifelse-value action = 0 [-1] [1])
  
  if paddle-x > 16 [
    set paddle-x 16
  ]
  
  if paddle-x < -16 [
    set paddle-x -16
  ]
   
  report replace-item 3 next-state paddle-x  ;; replace with the new paddle position
end


to-report get-best-action [state]  
  ;; get quality values for each action given the current state
  let state-key (get-key-from-state state)
  let row table:get quality state-key
  
  ;; return the action with max quality
  report ifelse-value (item 0 row > item 1 row) [0] [1]
end


to-report choose-action [state]
  if random 2 < er [
    report get-best-action state
  ]
  report int(random 2)
end



;; TODO: aggiustare ball-angle in base al range di valori
to-report get-key-from-state [state]
  let ball-x (item 0 state)
  let ball-y (item 1 state)
  let ball-angle (item 2 state)
  let paddle-x (item 3 state)
  
  let key ((ball-x + max-pxcor) * 1000000 + (ball-y + max-pycor) * 10000 + (ball-angle) * 100 + (paddle-x + max-pxcor))
  report (word key)
end


;; TODO: aggiustare ball-angle in base al range di valori
to-report get-state-from-key [string-key]
  let key (read-from-string string-key)
  
  let paddle-x (key mod 100)
  let ball-angle ((key mod 10000) - paddle-x) / 100
  let ball-y ((((key mod 1000000) - paddle-x) / 100) - ball-angle) / 100
  let ball-x (((((key mod 100000000) - paddle-x) / 100) - ball-angle) / 100 - ball-y) / 100
  
  show (list ball-x ball-y ball-angle paddle-x)
  
  set paddle-x paddle-x - (max-pxcor)
  set ball-angle ball-angle
  set ball-y ball-y - (max-pycor)
  set ball-x ball-x - (max-pxcor)
  
  report (list ball-x ball-y ball-angle paddle-x)
end


to-report get-reward [state action]
  let ball-x (item 0 state)
  let ball-y (item 1 state)
  let paddle-x (item 3 state)
  
  if ball-x != paddle-x [
    if ball-y = min-pycor  ;; player 1 loses
        [report 1]         ;; TODO: aggiustare in base a quale player impara
    
    if ball-y = max-pycor  ;; player 2 loses
        [report -1]        ;; TODO: aggiustare in base a quale player impara
  ]
  
  report 0  ;; nothing happens
end


